// ============================================
// FILE: lib/models/enums.dart
// All enums in one place for easy imports
// ============================================

enum Sport {
  powerlifting,
  crossfit,
  bodybuilding,
  olympicWeightlifting,
}

enum TrainingDay {
  monday,
  tuesday,
  wednesday,
  thursday,
  friday,
  saturday,
  sunday,
}

enum Phase {
  volume,
  strength,
  peak,
  deload,
  bulk,
  cut,
  technique,
  foundation,
  performance,
}

// Helper extensions to convert enums to display strings
extension SportExtension on Sport {
  String get displayName {
    switch (this) {
      case Sport.powerlifting:
        return 'Powerlifting';
      case Sport.crossfit:
        return 'CrossFit';
      case Sport.bodybuilding:
        return 'Bodybuilding';
      case Sport.olympicWeightlifting:
        return 'Olympic Weightlifting';
    }
  }

  String get icon {
    switch (this) {
      case Sport.powerlifting:
        return 'üèãÔ∏è';
      case Sport.crossfit:
        return 'ü§∏';
      case Sport.bodybuilding:
        return 'üí™';
      case Sport.olympicWeightlifting:
        return 'üèãÔ∏è‚Äç‚ôÄÔ∏è';
    }
  }
}

extension TrainingDayExtension on TrainingDay {
  String get displayName {
    switch (this) {
      case TrainingDay.monday:
        return 'Monday';
      case TrainingDay.tuesday:
        return 'Tuesday';
      case TrainingDay.wednesday:
        return 'Wednesday';
      case TrainingDay.thursday:
        return 'Thursday';
      case TrainingDay.friday:
        return 'Friday';
      case TrainingDay.saturday:
        return 'Saturday';
      case TrainingDay.sunday:
        return 'Sunday';
    }
  }

  String get shortName {
    return displayName.substring(0, 3).toUpperCase();
  }
}

extension PhaseExtension on Phase {
  String get displayName {
    switch (this) {
      case Phase.volume:
        return 'Volume Phase';
      case Phase.strength:
        return 'Strength Phase';
      case Phase.peak:
        return 'Peak Phase';
      case Phase.deload:
        return 'Deload';
      case Phase.bulk:
        return 'Bulk Phase';
      case Phase.cut:
        return 'Cut Phase';
      case Phase.technique:
        return 'Technique Phase';
      case Phase.foundation:
        return 'Foundation';
      case Phase.performance:
        return 'Peak Performance';
    }
  }
}

// ============================================
// FILE: lib/models/exercise.dart
// Exercise model with proper typing
// ============================================

class Exercise {
  final String name;
  final int? sets; // null for rest days
  final String reps; // Keep as string for ranges like "8-12"
  final int? repsMin; // Optional: for validation
  final int? repsMax; // Optional: for validation
  final double? intensityPercent; // 0.65 = 65%
  final String intensityDisplay; // "65-75%" for UI
  final bool isMain; // Main lift or accessory
  final String notes; // Additional info

  const Exercise({
    required this.name,
    this.sets,
    required this.reps,
    this.repsMin,
    this.repsMax,
    this.intensityPercent,
    this.intensityDisplay = '',
    this.isMain = false,
    this.notes = '',
  });

  // JSON serialization
  Map<String, dynamic> toJson() => {
        'name': name,
        'sets': sets,
        'reps': reps,
        'repsMin': repsMin,
        'repsMax': repsMax,
        'intensityPercent': intensityPercent,
        'intensityDisplay': intensityDisplay,
        'isMain': isMain,
        'notes': notes,
      };

  factory Exercise.fromJson(Map<String, dynamic> json) => Exercise(
        name: json['name'] as String,
        sets: json['sets'] as int?,
        reps: json['reps'] as String,
        repsMin: json['repsMin'] as int?,
        repsMax: json['repsMax'] as int?,
        intensityPercent: json['intensityPercent'] as double?,
        intensityDisplay: json['intensityDisplay'] as String? ?? '',
        isMain: json['isMain'] as bool? ?? false,
        notes: json['notes'] as String? ?? '',
      );

  // Copy with method for immutability
  Exercise copyWith({
    String? name,
    int? sets,
    String? reps,
    int? repsMin,
    int? repsMax,
    double? intensityPercent,
    String? intensityDisplay,
    bool? isMain,
    String? notes,
  }) {
    return Exercise(
      name: name ?? this.name,
      sets: sets ?? this.sets,
      reps: reps ?? this.reps,
      repsMin: repsMin ?? this.repsMin,
      repsMax: repsMax ?? this.repsMax,
      intensityPercent: intensityPercent ?? this.intensityPercent,
      intensityDisplay: intensityDisplay ?? this.intensityDisplay,
      isMain: isMain ?? this.isMain,
      notes: notes ?? this.notes,
    );
  }

  // Helper: Is this a rest day exercise?
  bool get isRest => sets == null || sets == 0;

  // Helper: Calculate volume (sets √ó reps average)
  double? get estimatedVolume {
    if (sets == null || repsMin == null) return null;
    final avgReps =
        repsMax != null ? (repsMin! + repsMax!) / 2 : repsMin!.toDouble();
    return sets! * avgReps;
  }
}

// ============================================
// FILE: lib/models/daily_workout.dart
// Daily workout model
// ============================================

class DailyWorkout {
  final TrainingDay day;
  final String focus;
  final List<Exercise> exercises;
  final bool isRestDay;

  const DailyWorkout({
    required this.day,
    required this.focus,
    required this.exercises,
    this.isRestDay = false,
  });

  Map<String, dynamic> toJson() => {
        'day': day.name,
        'focus': focus,
        'exercises': exercises.map((e) => e.toJson()).toList(),
        'isRestDay': isRestDay,
      };

  factory DailyWorkout.fromJson(Map<String, dynamic> json) => DailyWorkout(
        day: TrainingDay.values.firstWhere((d) => d.name == json['day']),
        focus: json['focus'] as String,
        exercises: (json['exercises'] as List)
            .map((e) => Exercise.fromJson(e as Map<String, dynamic>))
            .toList(),
        isRestDay: json['isRestDay'] as bool? ?? false,
      );

  // Helper: Rest day constructor
  factory DailyWorkout.rest(TrainingDay day) => DailyWorkout(
        day: day,
        focus: 'Rest & Recovery',
        exercises: const [],
        isRestDay: true,
      );

  // Helper: Total exercises
  int get exerciseCount => exercises.length;

  // Helper: Main lifts only
  List<Exercise> get mainLifts => exercises.where((e) => e.isMain).toList();

  // Helper: Accessories only
  List<Exercise> get accessories => exercises.where((e) => !e.isMain).toList();
}

// ============================================
// FILE: lib/models/program_week.dart
// Program week model
// ============================================

class ProgramWeek {
  final int weekNumber;
  final Phase phase;
  final String intensityRange;
  final int targetRPEMin;
  final int targetRPEMax;
  final List<DailyWorkout> dailyWorkouts;
  final String notes;

  const ProgramWeek({
    required this.weekNumber,
    required this.phase,
    required this.intensityRange,
    required this.targetRPEMin,
    required this.targetRPEMax,
    required this.dailyWorkouts,
    this.notes = '',
  });

  Map<String, dynamic> toJson() => {
        'weekNumber': weekNumber,
        'phase': phase.name,
        'intensityRange': intensityRange,
        'targetRPEMin': targetRPEMin,
        'targetRPEMax': targetRPEMax,
        'dailyWorkouts': dailyWorkouts.map((d) => d.toJson()).toList(),
        'notes': notes,
      };

  factory ProgramWeek.fromJson(Map<String, dynamic> json) => ProgramWeek(
        weekNumber: json['weekNumber'] as int,
        phase: Phase.values.firstWhere((p) => p.name == json['phase']),
        intensityRange: json['intensityRange'] as String,
        targetRPEMin: json['targetRPEMin'] as int,
        targetRPEMax: json['targetRPEMax'] as int,
        dailyWorkouts: (json['dailyWorkouts'] as List)
            .map((d) => DailyWorkout.fromJson(d as Map<String, dynamic>))
            .toList(),
        notes: json['notes'] as String? ?? '',
      );

  // Helper: Target RPE as list for backward compatibility
  List<int> get targetRPE => [targetRPEMin, targetRPEMax];

  // Helper: Get workout for specific day
  DailyWorkout? getWorkoutForDay(TrainingDay day) {
    try {
      return dailyWorkouts.firstWhere((w) => w.day == day);
    } catch (e) {
      return null;
    }
  }

  // Helper: Total training days (non-rest)
  int get trainingDays => dailyWorkouts.where((w) => !w.isRestDay).length;
}

// ============================================
// FILE: lib/models/workout_program.dart
// Complete workout program model
// ============================================

class WorkoutProgram {
  final String id; // Unique identifier
  final String name;
  final Sport sport;
  final int totalWeeks;
  final String description;
  final List<ProgramWeek> weeks;
  final DateTime createdAt;
  final DateTime? lastModified;

  const WorkoutProgram({
    required this.id,
    required this.name,
    required this.sport,
    required this.totalWeeks,
    required this.description,
    required this.weeks,
    required this.createdAt,
    this.lastModified,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'sport': sport.name,
        'totalWeeks': totalWeeks,
        'description': description,
        'weeks': weeks.map((w) => w.toJson()).toList(),
        'createdAt': createdAt.toIso8601String(),
        'lastModified': lastModified?.toIso8601String(),
      };

  factory WorkoutProgram.fromJson(Map<String, dynamic> json) => WorkoutProgram(
        id: json['id'] as String,
        name: json['name'] as String,
        sport: Sport.values.firstWhere((s) => s.name == json['sport']),
        totalWeeks: json['totalWeeks'] as int,
        description: json['description'] as String,
        weeks: (json['weeks'] as List)
            .map((w) => ProgramWeek.fromJson(w as Map<String, dynamic>))
            .toList(),
        createdAt: DateTime.parse(json['createdAt'] as String),
        lastModified: json['lastModified'] != null
            ? DateTime.parse(json['lastModified'] as String)
            : null,
      );

  // Helper: Get specific week
  ProgramWeek? getWeek(int weekNumber) {
    if (weekNumber < 1 || weekNumber > totalWeeks) return null;
    return weeks[weekNumber - 1];
  }

  // Helper: Get current phase for a week
  Phase getPhaseForWeek(int weekNumber) {
    final week = getWeek(weekNumber);
    return week?.phase ?? Phase.volume;
  }

  // Helper: Total training days in program
  int get totalTrainingDays {
    return weeks.fold(0, (sum, week) => sum + week.trainingDays);
  }

  // Copy with for updates
  WorkoutProgram copyWith({
    String? id,
    String? name,
    Sport? sport,
    int? totalWeeks,
    String? description,
    List<ProgramWeek>? weeks,
    DateTime? createdAt,
    DateTime? lastModified,
  }) {
    return WorkoutProgram(
      id: id ?? this.id,
      name: name ?? this.name,
      sport: sport ?? this.sport,
      totalWeeks: totalWeeks ?? this.totalWeeks,
      description: description ?? this.description,
      weeks: weeks ?? this.weeks,
      createdAt: createdAt ?? this.createdAt,
      lastModified: lastModified ?? this.lastModified,
    );
  }
}

// ============================================
// FILE: lib/models/workout_log.dart
// For storing actual workout logs
// ============================================

class WorkoutLog {
  final String id;
  final String userId;
  final String programId;
  final int weekNumber;
  final TrainingDay day;
  final DateTime completedAt;
  final List<ExerciseLog> exercises;
  final double averageRPE;
  final int totalVolume;
  final String notes;

  const WorkoutLog({
    required this.id,
    required this.userId,
    required this.programId,
    required this.weekNumber,
    required this.day,
    required this.completedAt,
    required this.exercises,
    required this.averageRPE,
    required this.totalVolume,
    this.notes = '',
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'programId': programId,
        'weekNumber': weekNumber,
        'day': day.name,
        'completedAt': completedAt.toIso8601String(),
        'exercises': exercises.map((e) => e.toJson()).toList(),
        'averageRPE': averageRPE,
        'totalVolume': totalVolume,
        'notes': notes,
      };

  factory WorkoutLog.fromJson(Map<String, dynamic> json) => WorkoutLog(
        id: json['id'] as String,
        userId: json['userId'] as String,
        programId: json['programId'] as String,
        weekNumber: json['weekNumber'] as int,
        day: TrainingDay.values.firstWhere((d) => d.name == json['day']),
        completedAt: DateTime.parse(json['completedAt'] as String),
        exercises: (json['exercises'] as List)
            .map((e) => ExerciseLog.fromJson(e as Map<String, dynamic>))
            .toList(),
        averageRPE: json['averageRPE'] as double,
        totalVolume: json['totalVolume'] as int,
        notes: json['notes'] as String? ?? '',
      );
}

class ExerciseLog {
  final String exerciseName;
  final List<SetLog> sets;

  const ExerciseLog({
    required this.exerciseName,
    required this.sets,
  });

  Map<String, dynamic> toJson() => {
        'exerciseName': exerciseName,
        'sets': sets.map((s) => s.toJson()).toList(),
      };

  factory ExerciseLog.fromJson(Map<String, dynamic> json) => ExerciseLog(
        exerciseName: json['exerciseName'] as String,
        sets: (json['sets'] as List)
            .map((s) => SetLog.fromJson(s as Map<String, dynamic>))
            .toList(),
      );

  // Helper: Average RPE for this exercise
  double get averageRPE {
    if (sets.isEmpty) return 0;
    return sets.map((s) => s.rpe).reduce((a, b) => a + b) / sets.length;
  }

  // Helper: Total volume
  int get totalVolume {
    return sets.fold(0, (sum, set) => sum + (set.weight * set.reps).toInt());
  }
}

class SetLog {
  final int setNumber;
  final double weight;
  final int reps;
  final double rpe;
  final DateTime timestamp;
  final String notes;

  const SetLog({
    required this.setNumber,
    required this.weight,
    required this.reps,
    required this.rpe,
    required this.timestamp,
    this.notes = '',
  });

  Map<String, dynamic> toJson() => {
        'setNumber': setNumber,
        'weight': weight,
        'reps': reps,
        'rpe': rpe,
        'timestamp': timestamp.toIso8601String(),
        'notes': notes,
      };

  factory SetLog.fromJson(Map<String, dynamic> json) => SetLog(
        setNumber: json['setNumber'] as int,
        weight: (json['weight'] as num).toDouble(),
        reps: json['reps'] as int,
        rpe: (json['rpe'] as num).toDouble(),
        timestamp: DateTime.parse(json['timestamp'] as String),
        notes: json['notes'] as String? ?? '',
      );

  // Helper: Estimated 1RM (Epley formula)
  double get estimated1RM {
    if (reps == 1) return weight;
    return weight * (1 + reps / 30);
  }

  // Helper: Volume for this set
  int get volume => (weight * reps).toInt();
}

// ============================================
// FILE: lib/models/user_progress.dart
// Track user progress through program
// ============================================

class UserProgress {
  final String userId;
  final String programId;
  final int currentWeek;
  final Map<int, bool> completedWeeks; // week number -> completed
  final DateTime startedAt;
  final DateTime? completedAt;
  final Map<String, double> personalRecords; // exercise name -> max weight

  const UserProgress({
    required this.userId,
    required this.programId,
    required this.currentWeek,
    required this.completedWeeks,
    required this.startedAt,
    this.completedAt,
    this.personalRecords = const {},
  });

  Map<String, dynamic> toJson() => {
        'userId': userId,
        'programId': programId,
        'currentWeek': currentWeek,
        'completedWeeks':
            completedWeeks.map((k, v) => MapEntry(k.toString(), v)),
        'startedAt': startedAt.toIso8601String(),
        'completedAt': completedAt?.toIso8601String(),
        'personalRecords': personalRecords,
      };

  factory UserProgress.fromJson(Map<String, dynamic> json) => UserProgress(
        userId: json['userId'] as String,
        programId: json['programId'] as String,
        currentWeek: json['currentWeek'] as int,
        completedWeeks: (json['completedWeeks'] as Map<String, dynamic>)
            .map((k, v) => MapEntry(int.parse(k), v as bool)),
        startedAt: DateTime.parse(json['startedAt'] as String),
        completedAt: json['completedAt'] != null
            ? DateTime.parse(json['completedAt'] as String)
            : null,
        personalRecords:
            Map<String, double>.from(json['personalRecords'] as Map? ?? {}),
      );

  // Helper: Is week unlocked?
  bool isWeekUnlocked(int weekNumber) {
    if (weekNumber == 1) return true; // Week 1 always unlocked
    if (weekNumber > currentWeek + 1) return false; // Can't skip weeks
    return completedWeeks[weekNumber - 1] ?? false;
  }

  // Helper: Progress percentage
  double get progressPercentage {
    final completed = completedWeeks.values.where((v) => v).length;
    return completed / completedWeeks.length;
  }

  // Copy with
  UserProgress copyWith({
    String? userId,
    String? programId,
    int? currentWeek,
    Map<int, bool>? completedWeeks,
    DateTime? startedAt,
    DateTime? completedAt,
    Map<String, double>? personalRecords,
  }) {
    return UserProgress(
      userId: userId ?? this.userId,
      programId: programId ?? this.programId,
      currentWeek: currentWeek ?? this.currentWeek,
      completedWeeks: completedWeeks ?? this.completedWeeks,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      personalRecords: personalRecords ?? this.personalRecords,
    );
  }
}

/*
WHAT YOU JUST GOT:

‚úÖ Clean separation of concerns
‚úÖ Proper typing (int, double, enums)
‚úÖ JSON serialization for Firebase
‚úÖ Immutable models with copyWith
‚úÖ Helper methods for calculations
‚úÖ No Flutter dependencies in models

NEXT FILES TO CREATE:
- lib/data/program_database.dart (refactored)
- lib/services/program_service.dart (business logic)
- lib/services/workout_service.dart (logging logic)

Want me to continue with the service layer?
*/